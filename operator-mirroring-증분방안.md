# 5000, 5001 포트의 넥서스 컨테이너 레지스트리를 활용한 업그레이드 전략
가정 1. 기존 미러는 5000포트 레지스트리에 구성되어 있음. <br/>
가정 2. 업그레이드하기위한 신규 오퍼레이터 번들만을 미러링해 반입한 신규 미러는 5001포트 레지스트리에 구성되어 있음.

```
# 5000번(기존) 인덱스에서 JSON 추출
$ opm render nexus.xxx.xxx.xxx:5000/olm/redhat-index:v4.20 > catalog/base.json

# 5001번(신규) 인덱스에서 JSON 추출
$ opm render nexus.xxx.xxx.xxx:5001/olm/redhat-index:v4.20 > catalog/new.json
```

```
# 합쳐진 전체 카탈로그 구조가 올바른지 검증 (네트워크 필요 없음)
opm validate catalog/
```

```
# Dockerfile 생성
$ opm generate dockerfile catalog/

# 빌드 및 푸시 (5000번 베이스 이미지 사용)
$ podman build -t nexus.xxx.xxx.xxx:5001/olm/redhat-index:v4.20-final .
$ podman push nexus.xxx.xxx.xxx:5001/olm/redhat-index:v4.20-final
```

:white_check_mark: 결론 : 위 방식대로 작업 시 최소한의 반입 파일만으로 업그레이드 작업이 가능합니다. 업그레이드 시 기존 오퍼레이터 번들정보가 신규 오퍼레이터 인덱스에서 유실되었더라도 기존 오퍼레이터 인덱스 정보를 활용하여 업그레이드에 문제가 생기지 않습니다.


:warning: 단!!!, 아래의 케이스에 대한 문제가 해결되지 않습니다.

1. 5000포트 미러
   - ocp 미러
   - A 오퍼레이터 미러
   - B 오퍼레이터 미러
   - C 오퍼레이터 미러
   - D 오퍼레이터 미러
2. 5001포트 미러
   
3. 업그레이드 대상 (5001포트 미러로 반입할 대상)
   - ocp
   - A 오퍼레이터

1차 업그레이드 작업 시 특정 오퍼레이터들이 업그레이드 대상이 아닌경우, 미러 구성은 아래와 같습니다.

1. 5000포트 미러
   - 기존 미러 인덱스
   - ocp 미러(기존)
   - A 오퍼레이터 미러(기존)
   - B 오퍼레이터 미러
   - C 오퍼레이터 미러
   - D 오퍼레이터 미러
2. 5001포트 미러
   - 신규 미러 인덱스(ocp와 A오퍼레이터에 대해 5000,5001포트 미러 모두에 대한 정보 저장)
   - ocp 미러(신규)
   - A 오퍼레이터 미러(신규)

:question: 2차 업그레이드 작업 시 업그레이드 할 미러들은 어디로 반입해야하는가? 어느 미러를 정리해야하는가?

<br/>

# 이에 대한 해결책으로 아래 방안들을 검토할 수 있습니다.

### 전략 1. '베이스(Base) 레지스트리' 유지 및 누적 전략 <br/>
5000번과 5001번을 별개의 저장소로 보지 말고, 5000번을 '운영(Production)' 포트로 고정하고 5001번은 '반입용(Staging)' 포트로 사용하는 방식입니다. <br/>
1) 반입 및 푸시: 2차 주기에 5001번으로 신규 미러 데이터를 반입합니다.
2) 데이터 통합 (skopeo copy): 5001번에 있는 신규 이미지들을 **5000번 레지스트리로 복사(Append)**합니다.
   * 이때 5000번을 지우는 게 아니라, 기존 이미지들 옆에 새 이미지들을 추가하는 것입니다.
3) 인덱스 업데이트: 5000번의 기존 인덱스 정보와 5001번의 신규 인덱스 정보를 합쳐서 최종 인덱스를 5000번에 푸시합니다.
* 장점: 1차 때 업그레이드 안 한 오퍼레이터 데이터가 5000번에 그대로 남아 있어 안전합니다.
* 단점: 5000번 레지스트리의 디스크 용량이 계속 늘어납니다. (하지만 오퍼레이터 데이터는 생각보다 크지 않습니다.)

### 전략 2. '진공 청소기' 방식 (필요한 것만 골라 담기) <br/>
만약 5000번을 반드시 날려야 한다면, 현재 클러스터가 실제로 사용 중인 오퍼레이터 이미지들만 5001번으로 이사시키는 방법입니다. <br/>
1) 현황 파악: 클러스터에서 사용 중인 모든 오퍼레이터의 Bundle Image 주소를 추출합니다.
2) 이미지 이사: skopeo copy 등을 사용하여 해당 이미지들만 5000번에서 5001번으로 복사합니다.
3) FBC 통합: 5000번에서 가져온 메타데이터(JSON)의 이미지 주소를 nexus:5001/...로 치환하여 통합 인덱스를 빌드합니다.
* 장점: 불필요한 과거 미러 데이터는 버리고, 실제 사용 중인 데이터만 5001번으로 압축해서 옮길 수 있습니다.

:white_check_mark: 결론 : 고객사 디스크가 여유롭다면 전략1을 아래의 이유로 더 추천합니다. 
* 인덱스 관리: 담당자가 바뀌어도 '통합 카탈로그 JSON' 파일만 Git에 잘 보관되어 있으면 언제든 인덱스를 복구할 수 있습니다.
* 데이터 관리: 넥서스 레지스트리(5000번)는 **"한 번 들어온 데이터는 지우지 않고 쌓아둔다(Append Only)"**는 원칙을 세우는 것이 사고를 방지하는 가장 확실한 방법입니다.

|비교 항목|전략 1: 운영 레지스트리에 누적 (Append)|전략 2: 필요한 것만 선별 이사 (Clean-up)|
|:---|:---|:---|
|핵심 개념|5000번(운영)에 새 데이터를 계속 추가|5000번에서 실제 쓰는 것만 골라 5001번으로 이동|
|작업 난이도|낮음 (skopeo copy 또는 oc-mirror push 끝)|높음 (사용 중인 이미지 리스트 추출 및 복사 작업 필요)|
|데이터 안전성|높음 (덮어쓰기 실수만 안하면 과거 데이터가 남아있음)|보통 (리스트 추출 시 누락되면 서비스 장애 발생)|
|저장소 효율|낮음 (불필요한 구버전 이미지도 계속 쌓임)|매우 높음 (필요한 최소 데이터만 남겨 최적화)|
|인덱스 관리|쉬움 (기본 JSON에 신규 JSON만 병합)|보통 (이미지 주소를 5001번으로 치환 작업 필요)|
|추천 대상|유지보수 담당자가 자주 바뀌는 환경|레지스트리 용량이 극도로 제한된 환경|
